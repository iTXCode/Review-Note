



#### URL和URI区别

- URL (统一资源定位符)正是使用 Web 浏览器等访问Web 页面时需要输入的网页地址。

组成:协议部分:// 网址部分/文件地址部分

- URI 就是由某个协议方案表示的资源的定位标识符
- URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）

- [ ] www.baidu.com:表示网址
- [ ] baidu.com表示域名
- [ ] .com表示顶级域名

- 常见的顶级域名

> **.com**:表示商业结构
>
> **.org**:非盈利结构
>
> **.gov**:政府结构
>
> **.edu**:教育及科研结构
>
> - [ ] 国家顶级域名
>
> **.cn**:中国
>
> **.us**:美国
>
> **.jp**:日本
>
> **.cc**:科科斯群岛



从域名后的第一个"/"到最后一个"/"为止这段为虚拟目录部分

从最后一个"/"到"#"为止这段为 **文件名部** 

"#"后面是锚部分

#### URN

- 给某个资源指定特定的名字,通过这个URN直接去在互联网中去寻找该资源.(资源可以没有特定的位置)

> 该过程需要一个特定的解析器在网络中寻找查找资源的最新位置信息.但是这个解析器构建起来代价特别大.



#### HTTP协议用途

- 用于服务器和客户端之间的通信提供资源响应的一端为服务器端

> 发起请求的一端为客户端,
>
> 响应请求地一端为服务器端



#### HTTP 报文首部

- 用于HTTP协议交互的信息。
- 请求报文:请求段的HTTP报文
- 响应报文:响应端的HTTP报文

- [ ] HTTP报文本身由多行(用CR＋LF作换行符)　数据构成的字符串文本

HTTP报文大致可分为　**报文首部**　和　**报文主体**　两块，两者由最初出现的空行（CR＋LF）来划分

- [ ] 一般格式



![](https://i.bmp.ovh/imgs/2020/10/5baa0d802bf3efa8.png)

- [ ] 请求报文和响应报文

![](https://i.bmp.ovh/imgs/2020/10/73ff72d6f507efbd.png)



- 首部内容为客户端和服务器端分别处理请求和响应提供所需要的信息

- [ ] 实例

![](https://i.bmp.ovh/imgs/2020/10/aa48e4d1065fcd6a.png)

- 请求行

> 包含用于请求的方法,请求URI和HTTP版本

- 状态行

> 包含表明响应结果的状态码,原因短语和HTTP版本

- 首部字段

> 包含表示请求和响应的各种条件和属性的各类首部

- 一般有4种首部,分别是:通用首部,请求首部,响应首部和实体首部



#### HTTP 请求报文

在请求中,HTTP报文由方法、URI、HTTP版本、HTTP首部字段等构成

![](https://i.bmp.ovh/imgs/2020/10/643f3e9978a2784c.png)

- 下面的示例是访问http://hackr.jp 时,请求报文的首部信息

![](https://i.bmp.ovh/imgs/2020/10/72f782a3a46def0c.png)

![](https://i.bmp.ovh/imgs/2020/10/46b4f0e0c2aa06ac.png)

#### HTTP响应报文

在响应中,HTTP报文由HTTP版本、状态码(数字和原因短语)、HTTP首部字段3部分构成

![](https://i.bmp.ovh/imgs/2020/10/d03600105b9bd925.png)

- 以下示例为请求访问http://hackr.jp/时,返回的响应报文的首部信息

![](https://i.bmp.ovh/imgs/2020/10/d5e0f3c7e6d79822.png)

#### 通用的首部字段

| 首部字段名        | 说明                 |
| ----------------- | -------------------- |
| **Cache-Control** | 控制缓存的行为       |
| **Connection**    | 逐跳首部、连接管理   |
| **Date**          | 创建报文的日期时间   |
| **Via**           | 代理服务器的相关信息 |

#### 请求首部字段

| 首部字段名         | 说明                       |
| ------------------ | -------------------------- |
| **Accept**         | 用户处理可以处理的媒体类型 |
| **Accept-Charset** | 优先的字符集               |
| **From**           | 用户的电子邮箱地址         |
| **Host**           | 请求资源所在服务器         |
| **Range**          | 实体的字节范围请求         |
| **Reference**      | 对请求中的URI的原始获取方  |
| **User-Agent**     | HTTP客户端程序的信息       |

#### 响应首部字段

| 首部字段名              | 说明                         |
| ----------------------- | ---------------------------- |
| **Accept-Authenticate** | 代理服务器对客户端的认证信息 |
| **Server**              | HTTP服务器的安装信息         |
| **Vary**                | 代理服务器缓存的管理信息     |
| **WWW-Authenticate**    | 服务器对客户端的认证信息     |

#### 实体首部字段

| 首部字段名           | 说明                      |
| -------------------- | ------------------------- |
| **Content-Length**   | 实体主体的大小(单位:字节) |
| **Connect-Language** | 实体主体的自然语言        |
| **Connect-Location** | 替代对应资源的URI         |
| **Connect-Type**     | 实体主体的媒体类型        |
| **Connect-MD5**      | 实体主体的报文摘要        |

#### 持久连接节省通信量

- HTTP协议的初始版本中,每进行一次HTTP通信就要断开一次TCP连接

![](https://i.bmp.ovh/imgs/2020/10/d7bcc9c04bb92de1.png)

这种情况对于容量小的文本传输,但是对于包含多张图片的HTML页面时,在发送请求访问HTML页面资源的同时,也会请求该HTML页面里包含的其他资源.

因此,每次的请求都会造成无谓的TCP连接建立和断开,增加通信量的开销

![](https://i.bmp.ovh/imgs/2020/10/0d26d3e8485fbbf9.png)

#### 持久连接

- 上述的问题总结起来就是最初的HTTP协议是没有状态的.

为了解决这个问题,提出了持久连接(HTTP keep-alive) 的方法, 

**特点:只要任意一端没有明确的提出断开连接,则保持TCP连接状态**

![image.png](https://i.loli.net/2020/10/31/lPK5MryepChmXOq.png)

- [ ] 好处 

- 1.减少了TCP连接的重复建立和断开所造成的额外开销,减轻了服务器端的负载
- 2.减少开销的那部分时间,使用HTTP请求和响应能够更早地结束,这样Web页面地显示速度也就相应提高了



**同时服务器也需要持久连接**

#### 使用Cookie地状态管理

HTTP是 **无状态** 协议,它不对之前发生过地请求和响应地状态进行管理,无法根据之前地状态进行本次地请求处理

若Web页面本身无法进行状态的管理(不记录已登录的状态),那么每次跳转新页面不是要再次登录,就是要在每次请求报文中附加参数来管理登录状态.



Cookie技术通过在请求和响应报文中写入了Cookie信息来控制客户短的状态

- Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息,通知客户端保存Cookie.
- 下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入Cookie值后发送出去
- 服务器端发现客户端发送过来的Cookie后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息

![image.png](https://i.loli.net/2020/10/31/AoSXdtw51Kq3rTZ.png)

![image.png](https://i.loli.net/2020/11/01/uQ6MYpPy1GDBHkU.png)

#### Session管理及Cookie应用

![image.png](https://i.loli.net/2020/11/01/OpXbKBLDvulPjy5.png)

- 一般使用Cookie来管理Session(会话)

**步骤1**： 客户端把用户ID和密码等登录信息放入报文的实体部分,通常是以POST方法(数据不会显示在URL中)把请求发送给服务器

**步骤2**: 服务器会发送用以识别用户的Session ID.

- 通过验证从客户端发送过来的登录信息进行身份认证,然后把用户的认证状态与Session ID绑定记录在服务器端
- 向客户端返回响应的时候,首部字段Set-Cookie内写入Session ID(用于区分不同用户的符号)

**步骤3**:客户端收到服务器端发来的Session ID后，会将其作为Cookie保存到本地,下次向服务器发送请求时,浏览器会自动发送Cookie，服务器可以通过验证收到的Session ID识别用户和其认证状态

#### HTTP状态码

我们知道在响应报文的首部的状态行中会显示响应的状态,那这个状态码有什么意义呢？

![image.png](https://i.loli.net/2020/11/01/sQmP6jpONKwArLu.png)

借助这个状态码,用户就可以知道服务器端对请求的处理情况

![image.png](https://i.loli.net/2020/11/01/fztBsp7ZNKqrO1g.png)

**状态码的分类**

|      | 类别                           | 原因短语                   |
| ---- | ------------------------------ | -------------------------- |
| 1XX  | Informational(信息性状态码)    | 接收的请求正在处理         |
| 2XX  | Success(成功状态码)            | 请求正常处理完毕           |
| 3XX  | Redirection(重定向状态码)      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error(客户端错误状态码) | 服务器无法处理请求         |
| 5XX  | Server Error(服务器错误状态码) | 服务器处理请求出错         |

**2XX 成功**

- 200 OK:表示从客户端发来的请求在服务器端被正常处理了
- 204 No Content:该状态表示服务器接收的请求已成功处理,但在返回的响应报文不含实体的主体部分
- 206 Partial Content:该状态码表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求,响应报文中包含由Content-Range指定范围的实体内容

![image.png](https://i.loli.net/2020/11/01/eurIym8Y6nJT5tN.png)

**3XX重定向**

- 301:永久重定向.该状态码表示请求的资源已经被分配了新的URI, **如果已经把资源对应的URI保存为书签了,这时应该按Location首部字段提示的URI重新保存**

![](https://www.853tv.cn/imgs/2020/11/2fd6dad4ea85fb52.png)

- 302 Found:临时重定向,该状态码表示请求的资源已分别了新的URI,希望用户(本次)能使用新的URI访问

> 禁止将POST方法改变成GET,但实际操作中并不会遵守

- 303 See Other:该状态码表示由于请求对应的资源存在着另一个URI,应使用GET方法定向获取请求的资源

> 302与303差别:303状态码明确表示客户端应当采用GET方法获取资源,302则没有该规则

![](https://www.853tv.cn/imgs/2020/11/79e30cd0e24c8a69.png)

- 307 Temporary Redirect:临时重定向,该状态码与302Found有着相同含义

> 区别:
>
> - 302标准禁止将POST变换成GET，但实际使用时大家并不遵守
> - 307会遵守浏览器标准,不会将POST变成GET



**4XX客户端错误**

- 400 Bad Request:该状态码表示请求报文中存在语法错误,当错误发生时,需修改请求的内容后再次发起请求
- 401 Unauthorized:该状态码表示发送的请求需要有通过HTTP认证的认证信息,另外若之前已进行过1次请求,则表示用户认证失败

![](https://www.853tv.cn/imgs/2020/11/29276b1e2e2d7550.png)



- 403 Forbidden: 该状态码对请求资源的访问服务器拒绝了,服务器端没有必要给出拒绝的详细理由,但如果想做说明的话,可以在实体的主要部分对原因进行描述

> 未获得文件系统的访问授权,访问权限出现某些问题(从未授权的发送源IP地址试图访问)等列举的情况都可能是发生403原因

- 404 Not Found:该状态码表明服务器上无法找到请求的资源.除此之外,也可以在服务器端拒绝请求且不说明理由时是使用

**5XX 服务器错误**

5XX的响应结果表明服务器本身发生错误

- 500 Internal Service Error:该状态码表明服务器端在执行请求时发生了错误,也有可能是Web应用存在的bug或某些临时的故障
- 503 Service Unavailable: 该状态码表明服务器暂时处于超载或正在停机维护,现在无法处理请求.



#### 与HTTP协作的Web服务器

##### 用单台虚拟主机实现多个域名

- 在相同的IP地址下,由于虚拟主机可以寄存多个不同的主机名和域名的Web网站,因此在发送HTTP请求时,必须在Host首部内完整指定主机名或域名的URI

![](https://www.853tv.cn/imgs/2020/11/255192954b611305.png)

##### 用于通信数据转发程序:代理、网关、隧道

- [ ] 代理

> 一种有转发功能的应用程序,它扮演了位于服务器和客户端 **"中间人"** 的角色,接收由客户端发送的请求并转发给服务器.同时也接收服务器返回的响应并转发给客户端

![](https://www.853tv.cn/imgs/2020/11/2d7b1c9026c5b80f.png)

**源服务器**：持有资源实体的服务器

**分类**

- 1.缓存代理

> 代理转发响应时,缓存代理会预先将资源的副本(缓存)保存在代理服务器上,当代理服务器再次接收到相同资源的请求时,就可以不从源服务器哪里获取资源,而是将之前的资源缓存作为响应返回



![](https://www.853tv.cn/imgs/2020/11/dcff78241bfe7a11.png)

- 透明代理

> 转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理.

- [ ] 网关

![](https://www.853tv.cn/imgs/2020/11/84ff5761ad44f4a1.png)

网关能使通信线路上的服务器提供非HTTP协议服务

利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接到安全



- [ ] 隧道

![](https://www.853tv.cn/imgs/2020/11/7fd04399e2303ce9.png)

隧道可按照要求建立起一条与其他服务器的通信线路,届时使用SSL等加密手段进行通信,

隧道的目的使确保客户端能与服务器进行安全的通信



隧道本身不会去解析HTTP请求,请求保持原样中转给之后的服务器,隧道会在通信双方断开连接时结束





#### HTTP 请求的完整过程

当用户在浏览器输入网址回车之后,网络协议都做了那些工作呢？

1.首先浏览器应用程序,他要解析出URL中的域名

2.根据域名获取对应的IP地址.首先从浏览器缓存中查看,如下可以查看浏览器中域名对应的ip的解析

```http
chrome://net-internals/#events
```

> 如果没有则从本机域名解析文件hosts(/etc/hosts)中查看,还没有则从LDNS、Rootserver域名服务器、国际顶级域名服务商的DNS的层层解析

- 若在浏览器缓存和本机域名解析文件中都没有找到的话,那就需要发起DNS请求获取IP地址
- 若在本地DNS缓存中还是没有找到对应的IP，则继续往上层的DNS域名服务器中去查找

3.拿到IP地址后,浏览器就可以发起与服务器的三次握手(TCP三次握手)

4.握手建立后,就开始组装HTTP请求报文,发送报文

5.服务器收到请求报文之后开始,请求报文解析,生成响应数据,发送响应数据

6.浏览器收到响应之后,开始渲染页面