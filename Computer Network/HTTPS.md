### HTTPS

> 在HTTP协议中有可能存在信息窃听或者身份伪装等安全问题,所以提出了HTTPS
>
> HTTP的数据通过SSL/TSL加密之后再传输给下面的层(TCP)

#### HTTP缺点

###### 1.通信使用明文(不加密),内容可能会被窃听.

> 通信加密,HTTP协议中没有加密机制,但是可以通过和SSL(安全套接层)或TLS(安全层传输协议),加密HTTP的通信内容

![](https://www.853tv.cn/imgs/2020/11/ae19599e1d9cedff.png)

- 把HTTP报文里面所含的内容进行加密处理
- HTTP客户端需要对HTTP报文进行加密处理后再发送请求,

###### 2.不验证通信方的身份,因此有可能遭遇伪装

- HTTP协议中的请求和响应不会对通信方进行确认.不论谁发送过来的请求都会返回响应。

> 无法确定请求发送至目标的Web服务器是否为真实意图返回响应的那台服务器(**有可能是伪装的Web服务器**)
>
> 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端(**有可能是伪装的客户端**)
>
> 无法确定正在通信的对方是否具备访问权限
>
> 无法判断请求是来自何方、出自谁手
>
> 即使是无意义的也会照单全收

- [ ] 查明对手的证书

HTTP协议无法确定通信方,但是SSL则可以.**SSL不仅提供加密处理,而且还使用一种被称为证书的手段,可以确定方**

证书由指的信赖的第三方机构颁发,用以证明服务器和客户端是实际存在的

![](https://www.853tv.cn/imgs/2020/11/1fc60e1cf3b0fed4.png)

- 使用证书,以证明通信方就是意料中的服务器。对使用者来说减少了个人信息泄漏的危险性
- 客户端持有证书即可完成个人身份的确认,也可用于对Web网站的认证环节

###### 3.无法证明报文的完整性,所以有可能已遭到篡改

如果没有办法确定报文的完整性,通常也就意味着没有办法判断信息是否准确

> 由于无法验证报文的完整性,所以数据在传输过程中是否被修改过.通信双方都不知道

- 那如何防止篡改呢？

为了解决这个问题在SSL提供了认证和加密处理及摘要功能(MD5)。



##### HTTP+加密+认证+完整性保护=HTTPS

![](https://www.853tv.cn/imgs/2020/11/eee2918637b54496.png)



![](https://www.853tv.cn/imgs/2020/11/36ea093d866b01b3.png)





SSL是独立于HTTP的协议,所以不光是HTTP协议，其他运行在应用层的协议军均可以配合SSL协议来使用

#### SSL/TLS

- 采用**公开密钥加密的**加密处理方式

> - 特点
>
> 加密算法是公开的,而密钥确实是保密的。

**共享密钥加密(对称密钥加密)的困境**

加密和解密使用同一个密钥的方式称为共享密钥加密,也叫做对称密钥加密





![](https://www.853tv.cn/imgs/2020/11/a0b5a068af59ff8c.png)

但是密钥是通过网络传输给通信方,因此在密钥传输的过程中不能保证密钥被攻击者盗用,一旦密钥被盗用了，则对称加密的过程也就失去了意义。

- 如果解决上述的困境呢？

**使用两把密钥的公开密钥加密**

- 使用一对非对称的密钥,一把叫做 **公钥** ,一把叫做 **私钥** 
- 公钥是随意发布的,谁都可以拿到.
- 私钥是不能让任何人知道,需要通信方私有



- [ ] 加密过程

![](https://www.853tv.cn/imgs/2020/11/c4615eae8401f302.png)

发送方通过公钥进行加密

接收方通过私钥进行解密



###### HTTPS采用混合加密

![](https://www.853tv.cn/imgs/2020/11/a56b276f895e5f44.png)

##### CA证书

公开密钥加密的方式还是存在一些问题,那就是无法证明公开密钥本身就是通信要使用的公开密钥

- 为了解决无法确认公开密钥正确性的问题,可以使用数字证书认证结构(CA)和其相关机关颁发的公开密钥证书



- [ ] 证书获取流程

- 服务器的运营人员向数字证书机构提出公开密钥的申请
- 数字证书认证机构在判明提出申请者的身份之后,会对申请的公开密钥做数字签名,然后分配这个已签名的公开密钥,并将该更公开密钥放入公钥人公钥证书绑定在一起
- 服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端,以进行公开密钥加密方式通信
- 接到证书的客户端可使用数字证书认证机构的公开密钥,对那张证书上的数字签名进行验证,
- [ ] 一旦验证通过,客户端便可明确两件事

- 1.认证服务器的公开密钥的是真实有效的数字证书认证机构
- 服务器的公开密钥是值得信赖的

![](https://www.853tv.cn/imgs/2020/11/db99d025fc48a20d.png)

#### HTTPS的验证机制

- 1.客户端发起一个http请求，连接到服务器的443端口。

- 2.服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。

- 3.验证证书的合法性

>  客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。

- 4.生成随机密码（RSA签名）

>  如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。

- 5.生成对称加密算法

>  验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。



**另外一种说法**

1.**Clinet hello** 消息:客户端通过发送 "clinet hello"消息向服务器发起握手请求,该消息包含了客户端所支持的TLS版本和密码组合以供服务器进行选择,还有一个 **client random** 随机字符串

2.**server hello** 消息: 服务器发送 **server hello** 消息对客户端进行回应,该消息包含了数字证书,服务器选择的密码组合和 **server random** 随机字符串

3.**验证**: 客户端对服务器发来的证书进行验证,确保对方的合法身份,验证过程可以细化为以下几个步骤

> - 1.检查数字签名
> - 2.验证证书链
> - 3.检查证书的有效期
> - 4.检查证书的撤回状态(撤回代表证书已经失效)

4.**premaster secret**字符串:客户端向服务器发送另外一个随机字符串 **premaster secret** (预主密钥),这个字符串是经过服务器的公钥加密过的,只有对应的私钥才能解密

5.**使用私钥**:服务器使用私钥解密**"premaster secret"** 

6.**生成共享密钥**:客户端和服务器均使用client random,server random和premaster secret,并通过相同的加密算法生成相同的共享密钥 **KEY**

7.**客户端就绪**:客户端发送经过共享密钥 **KEY** 加密过的 **finished** 信号

8.**服务器就绪**:服务器发送经过共享密钥 **KEY** 加密过的 **finished** 信号

9.**达成安全通信**: 握手完成,双方使用对称加密进行安全通信





##### SSL速度慢吗？

![1604237560613](E:\Github\Review-Note\Computer Network\HTTPS.assets\1604237560613.png)

**SSL慢的原因**

- 1.通信慢
- 2.另一种是指由于大量消耗CPU及内存等资源,导致处理速度变慢
- SSL必须进行加密处理,在服务器和客户端都需要进行加密和解密的运算处理.因此从结果上讲，比起HTTP会消耗服务器和客户端的硬件资源,导致负载增强



##### 为什么不一直使用HTTPS

我们知道HTTPS安全可靠,为什么不一直使用HTTPS？

- 1.与纯文本通信相比,加密通信会消耗更多的CPU及内存资源
- ２.节约购买证书的开销

